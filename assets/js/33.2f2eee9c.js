(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{431:function(e,t,a){"use strict";a.r(t);var v=a(56),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"打包原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打包原理"}},[e._v("#")]),e._v(" 打包原理")]),e._v(" "),a("h3",{attrs:{id:"流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[e._v("#")]),e._v(" 流程")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("初始化参数: 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；")])]),e._v(" "),a("li",[a("p",[e._v("开始编译: 用上一步得到的参数初始化 Compiler 对象, 加载所有配置的插件，执行对象的 run 方法开始执行编译；")])]),e._v(" "),a("li",[a("p",[e._v("确定入口：根据配置中的 entry 找出所有的入口文件；")])]),e._v(" "),a("li",[a("p",[e._v("编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；")])]),e._v(" "),a("li",[a("p",[e._v("完成模块编译: 在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；")])]),e._v(" "),a("li",[a("p",[e._v("输出资源: 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；")])]),e._v(" "),a("li",[a("p",[e._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。")])])]),e._v(" "),a("p",[e._v("在以上过程中，Webpack 会在特定的时间点广播出特定的事件, 插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。")]),e._v(" "),a("h3",{attrs:{id:"细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#细节"}},[e._v("#")]),e._v(" 细节")]),e._v(" "),a("p",[e._v("Webpack 的构建流程可以分为以下三大阶段：")]),e._v(" "),a("ol",[a("li",[e._v("初始化：启动构建，读取与合并配置参数, 加载 Plugin，实例化 Compiler。")]),e._v(" "),a("li",[e._v("编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。")]),e._v(" "),a("li",[e._v("输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。")])]),e._v(" "),a("p",[e._v("如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：")]),e._v(" "),a("p",[e._v("在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用，")])])}),[],!1,null,null,null);t.default=_.exports}}]);